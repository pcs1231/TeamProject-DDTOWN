package kr.or.ddit.ddtown.service.chat.dm;


import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.or.ddit.ddtown.mapper.chat.dm.ChatChannelMapper;
import kr.or.ddit.ddtown.mapper.community.CommunityProfileMapper;
import kr.or.ddit.ddtown.service.member.membership.IMembershipService;
import kr.or.ddit.vo.chat.dm.ChatChannelVO;
import kr.or.ddit.vo.chat.dm.ChatMessageVO;
import kr.or.ddit.vo.chat.dm.ParticipantsVO;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatChannelServiceImpl implements IChatChannelService {
	
	private final ChatChannelMapper chatChannelMapper;
	
	private final CommunityProfileMapper communitiyProfileMapper;
	
	private final IChatMessageService chatMessageService;
	
	private final IMembershipService membershipService;
	
	private final UserDetailsService userDetailsService;
	
	// 모든 채팅방 조회
	@Override
	public List<ChatChannelVO> findAllChannels(String currentUser) {
		return chatChannelMapper.findAllChannels(currentUser);
	}
	
	// 새로운 채팅방 생성
	@Override
	@Transactional
	public ChatChannelVO createChatChannel(int comuProfileNo, int artGroupNo, String chatTypeCode) {
		// 1. chatChannel 객체를 빌더를 사용하여 생성하고, 매퍼를 통해 저장
		ChatChannelVO chatChannel = ChatChannelVO.builder()
                .comuProfileNo(comuProfileNo)
                .artGroupNo(artGroupNo)
                .chatTypeCode(chatTypeCode)
                .build();
		
		chatChannelMapper.insertChatChannel(chatChannel);
		
		// 2. artistParticipant 객체를 빌더를 사용하여 생성하고, 매퍼를 통해 저장
		String artistUsername = communitiyProfileMapper.getMemUsernameByComuProfile(comuProfileNo);
		ParticipantsVO artistParticipant = ParticipantsVO.builder()
				.memUsername(artistUsername)
				.chatChannelNo(chatChannel.getChatChannelNo())
				.paciRoleCode("PRC001")
				.lastReadChatNo(0)
				.build();
				
		chatChannelMapper.insertParticipant(artistParticipant);
		
		return chatChannel;
	}
	
	// 채널 상세 정보 조회
	@Override
	public ChatChannelVO getChatChannelDetail(int chatChannelNo, String username, int meesageLimit) {
		// 1. 채널 및 아티스트 정보 조회
		ChatChannelVO chatChannelVO = chatChannelMapper.selectChatChannelDetailByChannelNo(chatChannelNo);
		
		if(chatChannelVO == null || !"CTC001".equals(chatChannelVO.getChatTypeCode())) {
			return null;
		}
		
		// 2. 현재 사용자 정보 및 권한 설정
		String myComuNicknm = chatChannelMapper.selectMyNicknmForChannel(username, chatChannelNo);
		chatChannelVO.setMyComuNicknm(myComuNicknm);
		
		chatChannelVO.setCurrentUsername(username);
		chatChannelVO.setArtist(username.equals(chatChannelVO.getArtistUsername()));
		
		boolean hasMembership = false;
		if(chatChannelVO.getArtGroupNo() != null) {
			hasMembership = membershipService.hasValidMembershipSubscription(username, chatChannelVO.getArtGroupNo());
		}
		chatChannelVO.setHasMembership(hasMembership);
		
		// 3. 초기 메세지 목록 로드
		List<ChatMessageVO> initialMessages = chatMessageService.getMessageHistory(chatChannelNo, meesageLimit);
		
		Authentication currentUserAuth = SecurityContextHolder.getContext().getAuthentication();
		boolean isCurrentUserArtist = currentUserAuth.getAuthorities().stream()
													.anyMatch(a -> a.getAuthority().equals("ROLE_ARTIST"));
		String artistUsername = chatChannelVO.getArtistUsername();
		
		// 초기 메세지 목록 필터링
		List<ChatMessageVO> fileterMessages = initialMessages.stream()
				.filter(message -> {
					if(isCurrentUserArtist) {
						// 아티스트인 경우
						return true;	
					} else {
						// 회원인 경우
						return message.getUsername().equals(username) || message.getUsername().equals(artistUsername);
					}
				})
				.collect(Collectors.toList());
		
		// 프로필 이미지 경로 설정
		for(ChatMessageVO message : fileterMessages) {
			String msgUsername = message.getUsername();
			String profileImgPath = communitiyProfileMapper.selectProfileImgPathByUsername(msgUsername);
			
			if(profileImgPath != null && !profileImgPath.isEmpty() && profileImgPath.contains("/upload/profiles")) {
				message.setUserProfileImgPath(profileImgPath);
			} else {
				message.setUserProfileImgPath(null);
			}
		}
		chatChannelVO.setInitialMessages(fileterMessages);
		
		return chatChannelVO;
	}
	
	// 채널 기본 정보, 아티스트 정보 조회
	@Override
	public ChatChannelVO findChatChannelWithArtistInfo(int chatChannelNo) {
		return chatChannelMapper.selectChatChannelDetailByChannelNo(chatChannelNo);
	}
	
	// 마지막 메세지 일자 업데이트
	@Override
	public void updateChatLastDate(int chatChannelNo) {
		chatChannelMapper.updateChatLastDate(chatChannelNo, new Date());	// 현재 시간으로 업데이트
	}
	
	// 현재 로그인한 사용자 커뮤니티 프로필 번호 조회
	@Override
	public int getComuProfileNoForChatChannel(int chatChannelNo, String currentUser) {
		ChatChannelVO chatChannel = chatChannelMapper.selectChatChannelInfoByChannelNo(chatChannelNo);
		
		if(chatChannel == null || chatChannel.getComuProfileNo() == null) {
			log.warn("getComuProfileNoForChatChannel: Channel info or artist comuProfileNo not found for channel {}", chatChannelNo);
			return -1;
		}
		Integer artistComuProfileNo = chatChannel.getComuProfileNo();
		
		// 프로필 번호 이용해 아티스트 그룹 번호 조회
		Integer artGroupNo = communitiyProfileMapper.selectArtistGroupNoByComuProfileNo(artistComuProfileNo);
		
		if(artGroupNo == null) {
			log.warn("getComuProfileNoForChatChannel: Artist group not found for comuProfileNo {}", artistComuProfileNo);
			return -1;
		}
		
		// 사용자 커뮤니티 프로필 번호 조회
		Integer userComuProfileNo = communitiyProfileMapper.selectComuprofileNoByMember(currentUser, artGroupNo);
		
		if (userComuProfileNo == null) {
            log.warn("getComuProfileNoForChatChannel: User's comuProfileNo not found for user {} in artGroup {}", currentUser, artGroupNo);
            return -1;
        }
		
		return userComuProfileNo;
	}

	// 채팅방 참여자 조회
	@Override
	public List<String> getChatParticipants(Integer chatChannelNo) {
		if(chatChannelNo == null) {
			return List.of();	// 빈 리스트 반환
		}
		return chatChannelMapper.selectChatParticipants(chatChannelNo);
	}

	// 참여자 권한 조회
	@Override
	public Authentication getAuthenticationForUser(String participantUsername) {
		if(participantUsername == null) {
			return null;
		}
		try {
			// userDetails 생성
			UserDetails userDetails = userDetailsService.loadUserByUsername(participantUsername);
			return new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
		} catch (org.springframework.security.core.userdetails.UsernameNotFoundException e) {
            log.warn("getAuthenticationForUser: 사용자 '{}'를 찾을 수 없습니다.", participantUsername);
            return null;
        } catch (Exception e) {
            log.error("getAuthenticationForUser: 사용자 '{}'의 인증 정보를 가져오는 중 오류 발생: {}", participantUsername, e.getMessage(), e);
            return null;
        }
	}
	
	/**
	 * 해당 아티스트 그룹 dm 채널 폐쇄 처리
	 */
	@Override
	public int deleteChannels(int artGroupNo) {
		return chatChannelMapper.deleteChannels(artGroupNo);
	}
}































