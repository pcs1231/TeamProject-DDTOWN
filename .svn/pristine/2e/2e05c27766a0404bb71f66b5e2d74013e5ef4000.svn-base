package kr.or.ddit.ddtown.service.kakaopay;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import kr.or.ddit.dto.kakaopay.ApproveRequest;
import kr.or.ddit.dto.kakaopay.KakaoPayApproveResponseDTO;
import kr.or.ddit.dto.kakaopay.KakaoPayCancelResponseDTO;
import kr.or.ddit.dto.kakaopay.KakaoPayReadyResponseDTO;
import kr.or.ddit.dto.kakaopay.ReadyRequest;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class KakaoPayServiceImpl implements IKakaoPayService {
	
	@Value("${cid}") // cid는 샘플에서 그대로 사용하므로 이렇게 주입
	private String cid;
	@Value("${kakaopay.api.secret.key}") // application.properties에서 변경된 키 이름
	private String kakaopaySecretKey; // 샘플과 동일한 변수명 사용
	
	@Value("${kakaopay.ready_url}")
	private String readyApiUrl;
	@Value("${kakaopay.approve_url}")
	private String approveApiUrl; 

	@Value("${kakaopay.sample.host}") // 콜백 URL에 사용할 호스트 정보
	private String sampleHost; 
	
	@Value("${kakaopay.cancel_url}")
	private String cancelApiUrl;
	
	@Override
	public Map<String, String> kakaoPayReady(
			String goodsName, 
			Integer totalAmount, 
			Integer totalQuantity,
			String username, 
			String partnerOrderId
			) throws Exception {
		log.info("kakaoPayReady() 호출 - goodsName: {}, totalAmount: {}, username: {}, partnerOrderId: {}", goodsName,
				totalAmount, username, partnerOrderId);
		
	    log.info("### KAKAOPAY SECRET KEY: [{}]", kakaopaySecretKey); 
	    log.info("### KAKAOPAY SECRET KEY Length: {}", kakaopaySecretKey.length()); 

	    try {
			RestTemplate restTemplate = new RestTemplate();

			HttpHeaders headers = new HttpHeaders();
			headers.add("Authorization", "DEV_SECRET_KEY " + kakaopaySecretKey.trim());
			// *** 중요 수정: Content-Type을 APPLICATION_JSON으로 변경 ***
			headers.setContentType(MediaType.APPLICATION_JSON); 

            // *** MultiValueMap 대신 ReadyRequest 객체 생성 ***
            // vatAmount는 0으로 보내는 것이 안전합니다.
            Integer vatAmountForRequest = 0; // 또는 totalAmount / 11; (당신의 계산 로직에 따라)

            ReadyRequest readyRequest = ReadyRequest.builder()
                .cid(cid)
                .partnerOrderId(partnerOrderId)
                .partnerUserId(username)
                .itemName(goodsName) // goodsName이 null이 아닌 유효한 문자열인지 다시 확인!
                .quantity(totalQuantity)
                .totalAmount(totalAmount)
                .taxFreeAmount(0) // 0으로 고정
                .vatAmount(vatAmountForRequest) // 계산된 vatAmount 사용
                .approvalUrl(String.format(sampleHost + "/goods/order/kakaoPaySuccess?orderNo=%s", partnerOrderId))
                .cancelUrl(String.format(sampleHost + "/goods/order/kakaoPayCancel?orderNo=%s", partnerOrderId))
                .failUrl(String.format(sampleHost + "/goods/order/kakaoPayFail?orderNo=%s", partnerOrderId))
                .build();

			// *** HttpEntity에 ReadyRequest 객체를 담아 보냅니다. ***
			HttpEntity<ReadyRequest> requestEntity = new HttpEntity<>(readyRequest, headers);

			ResponseEntity<KakaoPayReadyResponseDTO> response = restTemplate.postForEntity(readyApiUrl, requestEntity,
					KakaoPayReadyResponseDTO.class);

			if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
				KakaoPayReadyResponseDTO readyResponse = response.getBody();
				log.info("카카오페이 Ready API 호출 성공: {}", readyResponse);

				Map<String, String> resultMap = new HashMap<>();
				resultMap.put("tid", readyResponse.getTid());
				resultMap.put("next_redirect_pc_url", readyResponse.getNext_redirect_pc_url());

				return resultMap;
			} else {
				log.error("카카오페이 Ready API 호출 실패. 상태 코드: {}", response.getStatusCode());
				throw new RuntimeException("카카오페이 결제 준비 실패: API 응답 오류");
			}

		} catch (HttpClientErrorException e) {
			log.error("카카오페이 Ready API HTTP 오류: {} - {}", e.getStatusCode(), e.getResponseBodyAsString(), e);
			// 서버에서 반환한 오류 본문이 있다면 여기서 출력하여 확인 (e.getResponseBodyAsString())
			throw new RuntimeException("카카오페이 결제 준비 실패 (HTTP 에러): " + e.getResponseBodyAsString());
		} catch (Exception e) {
			log.error("카카오페이 Ready API 호출 중 예외 발생: {}", e.getMessage(), e);
			throw e;
		}
	}

    @Override
    public String getCid() {
        return this.cid;
    }

    @Override
    public KakaoPayApproveResponseDTO kakaoPayApprove(
            String tid, 
            String partnerOrderId, 
            String partnerUserId,
            String pgToken
            ) throws Exception {
        log.info("kakaoPayApprove() 호출 - tid: {}, partnerOrderId: {}, partnerUserId: {}, pgToken: {}", tid,
                partnerOrderId, partnerUserId, pgToken);

        try {
            RestTemplate restTemplate = new RestTemplate();

            HttpHeaders headers = new HttpHeaders();
            headers.add("Authorization", "SECRET_KEY " + kakaopaySecretKey.trim());
            // *** 중요 수정: Content-Type을 APPLICATION_JSON으로 변경 ***
            headers.setContentType(MediaType.APPLICATION_JSON);

            // *** MultiValueMap 대신 ApproveRequest 객체 생성 ***
            ApproveRequest approveRequest = ApproveRequest.builder()
                .cid(cid)
                .tid(tid)
                .partnerOrderId(partnerOrderId)
                .partnerUserId(partnerUserId)
                .pgToken(pgToken)
                .build();

            // *** HttpEntity에 ApproveRequest 객체를 담아 보냅니다. ***
            HttpEntity<ApproveRequest> requestEntity = new HttpEntity<>(approveRequest, headers);
            
			ResponseEntity<KakaoPayApproveResponseDTO> response = restTemplate.postForEntity(approveApiUrl,
					requestEntity, KakaoPayApproveResponseDTO.class 
			);

			if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
				KakaoPayApproveResponseDTO approveResponse = response.getBody();
				log.info("카카오페이 Approve API 호출 성공: {}", approveResponse);
				return approveResponse;
			} else {
				log.error("카카오페이 Approve API 호출 실패. 상태 코드: {}", response.getStatusCode());
				throw new RuntimeException("카카오페이 결제 승인 실패: API 응답 오류");
			}

		} catch (HttpClientErrorException e) {
			log.error("카카오페이 Approve API HTTP 오류: {} - {}", e.getStatusCode(), e.getResponseBodyAsString(), e);
			throw new RuntimeException("카카오페이 결제 승인 실패 (HTTP 에러): " + e.getResponseBodyAsString());
		} catch (Exception e) {
			log.error("카카오페이 Approve API 호출 중 예외 발생: {}", e.getMessage(), e);
			throw e;
		}
    }

    @Override
    public Map<String, Object> kakaoPayCancel(String tid, int cancelAmount) {
        log.info("kakaoPayCancel() 호출 - tid: {}, cancelAmount: {}", tid, cancelAmount);

        try {
            RestTemplate restTemplate = new RestTemplate();

            // 1. 헤더 설정
            HttpHeaders headers = new HttpHeaders();
            headers.add("Authorization", "DEV_SECRET_KEY " + kakaopaySecretKey.trim());
            // 카카오페이 취소 API는 application/x-www-form-urlencoded 타입을 권장합니다.
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            // 2. 요청 바디 설정 (MultiValueMap 사용)
            MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
            params.add("cid", cid); // 가맹점 코드
            params.add("tid", tid); // 결제 고유 번호
            params.add("cancel_amount", String.valueOf(cancelAmount)); // 취소할 금액
            params.add("cancel_tax_free_amount", "0"); // 취소 비과세 금액 (일반적으로 0으로 고정)
            // 필요하다면 추가 파라미터 (예: payload)

            // 3. HttpEntity 생성
            HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(params, headers);

            // 4. POST 요청
            // 응답은 KakaoPayCancelResponseDTO로 매핑합니다.
            ResponseEntity<KakaoPayCancelResponseDTO> response = restTemplate.postForEntity(
                cancelApiUrl, // @Value로 주입받은 취소 API URL 사용
                requestEntity,
                KakaoPayCancelResponseDTO.class // 새로 만든 취소 응답 DTO 사용
            );

            // 5. 응답 처리
            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                KakaoPayCancelResponseDTO cancelResponse = response.getBody();
                log.info("카카오페이 Cancel API 호출 성공: {}", cancelResponse);

                // 성공 응답에서 필요한 정보를 Map으로 반환
                Map<String, Object> resultMap = new HashMap<>();
                resultMap.put("status", cancelResponse.getStatus()); // 취소 상태 (CANCELED, PARTIAL_CANCELED 등)
                resultMap.put("tid", cancelResponse.getTid());
                resultMap.put("cancel_amount", cancelResponse.getCanceledAmount() != null ? cancelResponse.getCanceledAmount().getTotal() : 0);
                // 필요에 따라 더 많은 정보를 추가 (예: 취소된 금액, 남은 금액 등)

                return resultMap;
            } else {
                log.error("카카오페이 Cancel API 호출 실패. 상태 코드: {}", response.getStatusCode());
                Map<String, Object> errorMap = new HashMap<>();
                errorMap.put("error", "API 응답 오류");
                errorMap.put("status_code", response.getStatusCode().toString());
                return errorMap;
            }

        } catch (HttpClientErrorException e) {
            // HTTP 4xx, 5xx 에러 처리 (API 호출 자체는 성공했으나 서버에서 오류 응답을 보낸 경우)
            log.error("카카오페이 Cancel API HTTP 오류: {} - {}", e.getStatusCode(), e.getResponseBodyAsString(), e);
            Map<String, Object> errorMap = new HashMap<>();
            errorMap.put("error", "HTTP 에러: " + e.getResponseBodyAsString());
            errorMap.put("error_code", e.getStatusCode().toString()); // 카카오페이 응답에서 제공하는 error_code가 있을 수 있습니다.
            return errorMap;
        } catch (Exception e) {
            // 그 외 예상치 못한 예외 처리
            log.error("카카오페이 Cancel API 호출 중 예외 발생: {}", e.getMessage(), e);
            Map<String, Object> errorMap = new HashMap<>();
            errorMap.put("error", "예외 발생: " + e.getMessage());
            return errorMap;
        }
    }
}