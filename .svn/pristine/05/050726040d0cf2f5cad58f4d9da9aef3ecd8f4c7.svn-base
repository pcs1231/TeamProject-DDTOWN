package kr.or.ddit.ddtown.service.goods.cancel;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.or.ddit.ServiceResult;
import kr.or.ddit.ddtown.mapper.admin.goods.order.IAdminOrdersMapper;
import kr.or.ddit.ddtown.mapper.goods.IGoodsMapper;
import kr.or.ddit.ddtown.mapper.orders.ICancelMapper;
import kr.or.ddit.ddtown.mapper.orders.IPaymentMapper;
import kr.or.ddit.ddtown.service.kakaopay.IKakaoPayService;
import kr.or.ddit.dto.kakaopay.CancelRequest;
import kr.or.ddit.dto.kakaopay.KakaoPayCancelResponseDTO;
import kr.or.ddit.vo.PaginationInfoVO;
import kr.or.ddit.vo.order.OrderCancelVO;
import kr.or.ddit.vo.order.OrderDetailVO;
import kr.or.ddit.vo.order.OrdersVO;
import kr.or.ddit.vo.order.PaymentVO;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class CancelServiceImpl implements ICancelService {
	
	@Autowired
	private IAdminOrdersMapper adminOrdersMapper; //주문 상태 업뎃용
	
	@Autowired
	private IGoodsMapper goodsMapper; //재고 복구용
	
	@Autowired
	private ICancelMapper cancelMapper; //Cancel 테이블 기록용
	
	@Autowired
	private IPaymentMapper paymentMapper; //결제 상태 업데이트용
	
	@Autowired
	private IKakaoPayService kakaoPayService;
	
	@Override
    @Transactional
    public ServiceResult processAdminOrderCancel(OrdersVO order, String empUsername) {
        log.info("### CancelServiceImpl - processAdminOrderCancel 호출: orderId={}, empUsername={}", order.getOrderNo(), empUsername);

        try {
            // 1. ORDERS 테이블의 주문 상태를 '취소 완료'로 변경 (OSC008)
            OrdersVO updateOrderVO = new OrdersVO();
            updateOrderVO.setOrderNo(order.getOrderNo());
            updateOrderVO.setOrderStatCode("OSC008"); // 공통 코드 '취소 완료'

            int statusUpdateCount = adminOrdersMapper.updateOrder(updateOrderVO);
            if (statusUpdateCount <= 0) {
                log.error("주문(orderId={}) 상태 변경 실패.", order.getOrderNo());
                throw new RuntimeException("주문 상태 변경 실패");
            }
            // ★ 로그 메시지 수정: CSC003 -> OSC008
            log.info("주문(orderId={}) 상태가 '취소 완료(OSC008)'로 변경되었습니다.", order.getOrderNo()); 

            // 2. 주문 상세 정보의 재고 복구 및 CANCEL 테이블 기록 
            if (order.getOrderDetailList() != null && !order.getOrderDetailList().isEmpty()) {
                for (OrderDetailVO detail : order.getOrderDetailList()) {
                    // 각 주문 상세 항목에 대해 재고 복구
                    log.info("### CancelServiceImpl - 재고 복구 시도: orderDetNo={}, goodsNo={}, goodsOptNo={}, orderDetQty={}",
                             detail.getOrderDetNo(), detail.getGoodsNo(), detail.getGoodsOptNo(), detail.getOrderDetQty());

                    int updatedRows = goodsMapper.increaseGoodsStock(
                        detail.getGoodsNo(),
                        detail.getGoodsOptNo(),
                        detail.getOrderDetQty()
                    );

                    log.info("### CancelServiceImpl - increaseGoodsStock 호출 (재고 복구): 상품번호={}, 옵션번호={}, 수량={}, 결과={}",
                             detail.getGoodsNo(), detail.getGoodsOptNo(), detail.getOrderDetQty(), updatedRows);

                    if (updatedRows == 0) {
                        log.error("상품(goodsNo={}, goodsOptNo={}) 재고 복구 실패. 주문 수량={}",
                                  detail.getGoodsNo(), detail.getGoodsOptNo(), detail.getOrderDetQty());
                        throw new RuntimeException("재고 복구 실패");
                    }

                    // 각 주문 상세 항목에 대해 CANCEL 테이블에 취소 기록 INSERT
                    OrderCancelVO cancelVO = new OrderCancelVO();
                    cancelVO.setOrderNo(order.getOrderNo());
                    cancelVO.setGoodsNo(detail.getGoodsNo()); 

                    cancelVO.setCancelType("CT003"); // 관리자 주문 취소
                    cancelVO.setCancelReasonCode("CRC001"); // 예시: 고객 변심 (실제로는 관리자가 선택한 사유)
                    cancelVO.setCancelStatCode("CSC003"); // 취소 완료

                    cancelVO.setEmpUsername(empUsername);
                    cancelVO.setMemUsername(order.getCustomerId());
                    // ★ 로그 메시지에서 "결제 API 미연동 테스트" 부분 삭제 또는 수정
                    cancelVO.setCancelReasonDetail("관리자 직접 전체 취소"); 

                    // 현재 루프의 상품에 대한 취소 수량
                    cancelVO.setCancelItemQty(detail.getOrderDetQty());

                    // ★★★ 이 부분을 재수정합니다 ★★★
                    long itemUnitPrice = 0; // 상품 1개당 단가

                    // 옵션이 선택된 경우 (goodsOptNo가 유효한 경우)
                    if (detail.getGoodsOptNo() != null && detail.getGoodsOptNo() > 0) {
                        itemUnitPrice = detail.getGoodsOptPrice(); // 옵션 단가 사용
                    } else {
                        itemUnitPrice = detail.getGoodsPrice(); // 상품 기본 단가 사용
                    }

                    // 최종 취소 금액은 단가 * 수량
                    int calculatedCancelPrice = (int) (itemUnitPrice * detail.getOrderDetQty());

                    cancelVO.setCancelReqPrice(calculatedCancelPrice); // 각 상품별 취소 요청 금액
                    cancelVO.setCancelResPrice(calculatedCancelPrice); // 각 상품별 최종 처리 금액

                    cancelVO.setCancelAccountNo(null);
                    cancelVO.setCancelAccountHol(null);

                    int cancelInsertCount = cancelMapper.insertCancel(cancelVO);
                    if (cancelInsertCount <= 0) {
                        log.error("CANCEL 테이블에 상품(goodsNo={}) 취소 기록 INSERT 실패. orderId={}", detail.getGoodsNo(), order.getOrderNo());
                        throw new RuntimeException("상품 취소 기록 생성 실패");
                    }
                    log.info("CANCEL 테이블에 주문(orderId={}) 상품(goodsNo={}) 취소 기록이 성공적으로 추가되었습니다.", order.getOrderNo(), detail.getGoodsNo());
                }
            } else {
                log.warn("### CancelServiceImpl - 주문(orderNo={}) 상세 정보가 없어 재고 복구 및 취소 기록 대상이 없습니다.", order.getOrderNo());
                throw new RuntimeException("주문 상세 정보 없음. 재고 복구 및 취소 기록 불가.");
            }

            // 3. 결제 정보 조회 (카카오페이 TID 및 결제 금액을 가져오기 위함)
            PaymentVO payment = paymentMapper.selectPaymentByOrderNo(order.getOrderNo()); // IPaymentMapper에 해당 메서드 구현 필요

            // 4. PG사(카카오페이) API를 통한 결제 취소 요청
            // OrdersVO의 orderPayMethodNm 필드를 사용하는 것이 좋습니다. (PaymentVO에 payMethodNm이 없으므로)
            if (payment != null && payment.getTid() != null && "카카오페이".equals(order.getOrderPayMethodNm())) { 
                log.info("카카오페이 결제 취소 API 호출 시도: orderNo={}, tid={}, totalAmount={}", 
                         order.getOrderNo(), payment.getTid(), payment.getTotalAmount()); 
            
             // 기존 Map<String, Object> 대신 KakaoPayCancelResponseDTO 타입으로 변경
                KakaoPayCancelResponseDTO cancelResponse = null;
                try {
                    // CancelRequest DTO를 생성하여 인자로 전달
                    CancelRequest cancelRequest = new CancelRequest();
                    // PaymentVO에서 cid를 가져오거나, kakaoPayService에서 기본 cid를 가져옵니다.
                    cancelRequest.setCid(payment.getCid() != null ? payment.getCid() : kakaoPayService.getCid());
                    cancelRequest.setTid(payment.getTid());
                    cancelRequest.setCancelAmount(payment.getTotalAmount()); // 전체 취소이므로 결제된 총 금액 사용
                    cancelRequest.setCancelTaxFreeAmount(0); // 비과세 금액은 0으로 설정

                    cancelResponse = kakaoPayService.kakaoPayCancel(cancelRequest); // 변경된 메서드 호출
                } catch (Exception e) {
                    log.error("카카오페이 결제 취소 API 호출 중 예외 발생 (orderNo: {}): {}", order.getOrderNo(), e.getMessage(), e);
                    throw new RuntimeException("카카오페이 결제 취소 API 호출 실패: " + e.getMessage(), e);
                }
            
             // 카카오페이 취소 응답 확인 및 처리
                // kakaoCancelResult 대신 cancelResponse DTO를 사용
                if (cancelResponse == null ||
                    (!"CANCELED".equals(cancelResponse.getStatus()) && !"PARTIAL_CANCELED".equals(cancelResponse.getStatus()))) {

                    String errorMessage = "카카오페이 취소 응답: " + (cancelResponse != null ? cancelResponse.getStatus() : "null response");
                    log.error("카카오페이 결제 취소 실패 (관리자 요청): orderNo={}, tid={}, 응답: {}", order.getOrderNo(), payment.getTid(), cancelResponse);
                    throw new RuntimeException("카카오페이 결제 취소에 실패했습니다: " + errorMessage);
                }
                log.info("카카오페이 결제(orderNo={}) 성공적으로 취소되었습니다 (관리자 요청). 응답: {}", order.getOrderNo(), cancelResponse);
                
                // PG사 취소 성공 시 Payment 테이블의 상태 업데이트 (PSC003: 결제 취소 완료)
                PaymentVO paymentStatusUpdate = new PaymentVO();
                paymentStatusUpdate.setOrderNo(order.getOrderNo()); 
                paymentStatusUpdate.setPaymentStatCode("PSC003"); 
                int paymentStatusUpdateCount = paymentMapper.updatePaymentStatus(paymentStatusUpdate); 
                if (paymentStatusUpdateCount <= 0) {
                    log.error("결제(orderNo={}) 상태를 '취소 완료(PSC003)'로 업데이트 실패.", order.getOrderNo());
                    throw new RuntimeException("결제 상태 업데이트 실패");
                }
                log.info("결제(orderNo={}) 상태가 '취소 완료(PSC003)'로 성공적으로 변경되었습니다.", order.getOrderNo());
            
            } else {
                log.info("주문(orderNo={})은 카카오페이 결제가 아니거나 유효한 TID 정보가 없어 PG사 취소 API를 호출하지 않습니다.", order.getOrderNo());
                
                // 카카오페이 결제가 아니어도 payment 상태는 '취소 완료'로 업데이트 (무통장 입금 등 DB만 처리)
                PaymentVO paymentStatusUpdate = new PaymentVO();
                paymentStatusUpdate.setOrderNo(order.getOrderNo()); 
                paymentStatusUpdate.setPaymentStatCode("PSC003"); 
                int paymentStatusUpdateCount = paymentMapper.updatePaymentStatus(paymentStatusUpdate);
                if (paymentStatusUpdateCount <= 0) {
                    log.error("비 카카오페이 결제(orderNo={}) 상태를 '취소 완료(PSC003)'로 업데이트 실패.", order.getOrderNo());
                    throw new RuntimeException("결제 상태 업데이트 실패");
                }
                log.info("비 카카오페이 결제(orderNo={}) 상태가 '취소 완료(PSC003)'로 성공적으로 변경되었습니다.", order.getOrderNo());
            }
            
            return ServiceResult.OK;
            
        } catch (Exception e) {
            log.error("CancelServiceImpl에서 주문 취소 처리 중 예외 발생: {}", e.getMessage(), e);
            throw new RuntimeException("주문 취소 처리 중 오류 발생", e);
        }
    }

    /**
     * 검색 및 필터링 조건에 따라 취소/환불 내역을 조회합니다.
     * 이 메서드는 사용자가 검색 또는 필터링 조건을 입력했을 때 AJAX 요청으로 호출됩니다.
     * @param filterParams 검색 키워드(searchKeyword)와 상태 코드(statusCode)를 포함하는 Map
     * @return 필터링된 OrderCancelVO 목록
     */
    @Override
    public int getTotalCancelRefundCount(PaginationInfoVO<OrderCancelVO> pagingVO) {
        log.info("getTotalCancelRefundCount() 호출: 필터링 조건 - {}", pagingVO.getSearchMap());
        return cancelMapper.selectTotalCancelRefundCount(pagingVO);
    }

	@Override
	public OrderCancelVO selectCancelDetail(int cancelNo) {
		return cancelMapper.selectCancelDetail(cancelNo); // 매퍼 호출
	}

	@Override
	public int updateCancelRefund(OrderCancelVO orderCancelVO) {
        log.info("취소/환불 데이터 업데이트 서비스 호출: {}", orderCancelVO);
        return cancelMapper.updateCancelRefund(orderCancelVO);
	}

    @Override
    public List<OrderCancelVO> getFilteredCancelRefunds(PaginationInfoVO<OrderCancelVO> pagingVO) {
        log.info("getFilteredCancelRefunds() 호출: 필터링 조건 - {}", pagingVO.getSearchMap());
        // PaginationInfoVO 객체에는 이미 startRow와 endRow가 계산되어 있으므로, Mapper는 이 값들을 사용하면 됩니다.
        return cancelMapper.selectFilteredCancelRefunds(pagingVO);
    }
}
