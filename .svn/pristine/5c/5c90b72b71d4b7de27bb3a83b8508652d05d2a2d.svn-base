package kr.or.ddit.ddtown.service.alert;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import kr.or.ddit.ddtown.mapper.alert.IAlertMapper;
import kr.or.ddit.ddtown.mapper.common.ICommonCodeMapper;
import kr.or.ddit.ddtown.mapper.community.ICommunityMainPageMapper;
import kr.or.ddit.vo.alert.AlertReceiverVO;
import kr.or.ddit.vo.alert.AlertSettingVO;
import kr.or.ddit.vo.alert.AlertVO;
import kr.or.ddit.vo.common.CommonCodeDetailVO;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class AlertServiceImpl implements IAlertService {
	
	@Autowired
	private IAlertMapper alertMapper;
	
	@Autowired
	private SimpMessagingTemplate messagingTemplate;
	
	@Autowired
	private ICommonCodeMapper commonCodeMapper;
	
	@Autowired
	private ICommunityMainPageMapper communityMainPageMapper;

	@Override
	@Transactional
	public void createAlert(AlertVO alert, List<String> recipientUsernames) throws Exception {
		log.info("createAlert() 실행...! 알림내용: {}, 알림타입: {}", alert.getAlertContent(), alert.getAlertTypeCode());
		
		// 알림 정보 저장
		if(alert.getAlertCreateDate() == null) {
			alert.setAlertCreateDate(new Timestamp(System.currentTimeMillis()));		// 알림 밀리초로 생성
		}
		
		
		int result = alertMapper.insertAlert(alert);
		
		if(result == 0) {
			log.error("알림 정보 저장 실패!!");
		}
		
		long generatedAlertNo = alert.getAlertNo();
		
		if(generatedAlertNo == 0) {
			log.error("알림 생성 실패 -> 알림 ID 못가져옴");
		}
		
		// 수신자 정보 저장 후 실시간 알림 발송
		for(String username : recipientUsernames) {
			List<AlertSettingVO> userSettings = alertMapper.selectAlertSettings(username);		// 회원의 알림세팅 가져오기
			boolean canSendAlert = userSettings.stream()
					.filter(s -> s.getAlertTypeCode()
					.equals(alert.getAlertTypeCode()))		// 알림유형코드가 일치할때
					.findFirst()
					.map(s -> "Y".equalsIgnoreCase(s.getAlertEnabledYn()))		// 알림설정 Y일때 보내도록 설정
					.orElse(true);		// 해당 타입에 대한 설정이 없으면 기본값 전송
			
			if(!canSendAlert) {
				log.info("회원 {}는 {}유형 알림 안받습니당", username, alert.getAlertTypeCode());
				continue;		// 다음 수신자로 넘어가기
			}
			
			AlertReceiverVO receiver = new AlertReceiverVO();
			receiver.setAlertNo(generatedAlertNo);		// 알림 번호 설정
			receiver.setMemUsername(username);			// 회원 아이디 설정
			receiver.setAlertGetDate(null);				
			receiver.setAlertReadYn("N");				// 기본값 'N' (안읽음)
			receiver.setAlertDelYn("N");				// 기본값 'N' (삭제안됨)
			int receiverResult = alertMapper.insertAlertReceiver(receiver);
			
			if(receiverResult == 0) {
				log.warn("회원 {}에 대한 알림 수신자 저장 실패, 알림번호: {}", username, generatedAlertNo);
				continue;
			}
			
			
			try {
				// 각 ServiceImpl에서 호출시 url주소 담아보냄
				List<AlertVO> singleAlertList = new ArrayList<>();
				singleAlertList.add(alert);		// 현재 alert 객체 (artGroupNo, profileNo, boardTypeCode 등)
				completeAlertUrls(singleAlertList);
				AlertVO completeAlert = singleAlertList.get(0);		// 완성된 URL 담긴 객체 초기화
				messagingTemplate.convertAndSendToUser(username, "/queue/alerts", completeAlert);		// 완성된 URL 담긴 객체 전송
				log.info("WebSocket 알림 전송 완료: 회원 -{}, 알림 번호 - {}", username, generatedAlertNo);
				
			} catch (Exception e) {
				log.error("WebSocket 알림 전송 실패: 회원 -{}, 알림 번호 - {}", username, generatedAlertNo);
			}
		}
	}

	@Override
	public List<AlertVO> getAlertsByUsername(String memUsername, int alertNo, int cnt, Integer artGroupNo) throws Exception {
		log.debug("getAlertsByUsername() 실행...! 회원: {}, alertNo: {}, cnt: {}, artGroupNo: {}", memUsername, alertNo, cnt, artGroupNo);

		
		Map<String, Object> params = new HashMap<>();
		  
		params.put("memUsername", memUsername);
		params.put("alertNo", alertNo);
		params.put("cnt", cnt);
		params.put("artGroupNo", artGroupNo);
		
		List<AlertVO> alertList = alertMapper.selectAlertsByUsername(params);
		
		completeAlertUrls(alertList);
		
		return alertMapper.selectAlertsByUsername(params);
	}
	
	private void completeAlertUrls(List<AlertVO> alertList) {
		String profileBaseUrl = "/profile/"; // 프로필 페이지 기본 URL 경로
        String communityBaseUrl = "/community/"; // 커뮤니티 기본 URL 경로
        String chatBaseUrl = "/chat/dm/channel/"; // 채팅방 기본 URL 경로
        String liveBaseUrl = "/live/stream/"; // 라이브 스트림 기본 URL 경로
        String mypageBaseUrl = "/mypage/membership/"; // 멤버십 기본 URL 경로
        String concertDetailBaseUrl = "/community/concert/detail/";		// 콘서트 상세 페이지 추후에 삽입
		
        for(AlertVO alert : alertList) {
        	String finalUrl = "";		// 최종경로 초기화용
        	Long relatedItemNo = alert.getRelatedItemNo();			// 게시물 번호
        	Integer profileNo = alert.getRelatedTargetProfileNo();	// 게시물이 속한 커뮤니티 프로필 번호
        	Integer artGroupNo = alert.getArtGroupNo();				// 게시물이 속한 아티스트 그룹 번호
        	String boardTypeCode = alert.getBoardTypeCode();		// 게시판 타입
        	
        	switch (alert.getAlertTypeCode()) {
        		case "ATC001":		// 새 커뮤니티 게시글
        		case "ATC005":		// 좋아요
        			// 커뮤니티 프로필 있을경우
        			if(profileNo != null && artGroupNo != null && relatedItemNo != null) {
        				// 해시태그와 함께 관련코드 넘겨서 모달창 바로뜨게 구현
        				finalUrl = communityBaseUrl + artGroupNo + profileBaseUrl + profileNo + "#post-" + relatedItemNo;		
        				// finalUrl += "#post-" + relatedItemNo;	
        			} else {
        				if(artGroupNo != null) {
        					finalUrl = communityBaseUrl + "gate/" + artGroupNo + "/apt"; // 프로필 정보 없으면 아티스트 게이트로 이동
        				} else {
        					finalUrl = communityBaseUrl + "main";		// 둘다 null이면 커뮤니티 메인페이지로 이동
        				}
        			}
        			break;
        		case "ATC002":		// 새로운 댓글
        			if(profileNo != null && artGroupNo != null && relatedItemNo != null) {
        				// community/{artGroupNo}/profile/{profileNo}
        				// 해시태그와함께 관련코드넘겨서 모달창 바로뜨게 구현
        				finalUrl = communityBaseUrl + artGroupNo + profileBaseUrl +profileNo + "#post-" + relatedItemNo;
        			} else {
        				if(artGroupNo != null) {
        					finalUrl = communityBaseUrl + "gate/" + artGroupNo + "/apt";
        				} else {
        					finalUrl = communityBaseUrl + "main";
        				}
        			}
        			break;
        		case "ATC003":		// 새로운 채팅
        			if(profileNo != null) {
        				finalUrl = chatBaseUrl + "enter/" + "아티스트번호";	// 채팅 발신자의 프로필주소 정해야댐.. (/chat/dm/channel/enter/{channel_id})
        			} else {
        				finalUrl = liveBaseUrl + relatedItemNo;		// 라이브 스트림으로 이동
        			}
        		case "ATC004":		// 라이브 시작
        			if(relatedItemNo != null) {
        				finalUrl = liveBaseUrl + relatedItemNo;		// /live/stream/{LIVE_NO}
        			} else {
        				log.warn("라이브 시작 알림에 LIVE_NO가 NULL.. URL 생성 불가");
        				finalUrl = "/live";		// 라이브 목록 페이지로 보내야할듯
        			}
        			break;
        		case "ATC006":		// 멤버십
        			if(relatedItemNo != null) {
        				finalUrl = mypageBaseUrl + relatedItemNo;
        			}
        			break;
        		case "ATC007":		// 새로운 콘서트 일정
        			if(profileNo != null && artGroupNo != null) {
        				finalUrl = communityBaseUrl + artGroupNo + profileBaseUrl + profileNo + "/concert/" + relatedItemNo;
        			} else {
        				finalUrl = communityBaseUrl + "concert/detail" + relatedItemNo;		// 프로필 정보 없으면 콘서트로 이동
        			}
        			break;
        		default:
        			// 저장된 URL이 없으면 기본 알림내역 페이지로 이동
        			if(alert.getAlertUrl() != null && !alert.getAlertUrl().isEmpty()) {
        				finalUrl = alert.getAlertUrl();
        			} else {
        				finalUrl = "/mypage/alerts";	// 알림내역 페이지
        			}
        			break;
        	}
        	alert.setAlertUrl(finalUrl);
        	log.debug("alertNo: {}, Type: {}, Final URL: {}", alert.getAlertNo(), alert.getAlertTypeCode(), alert.getAlertUrl());
        }
	}

	@Override
	public List<AlertVO> getLatestAlertsByUsername(String memUsername, int cnt, Integer artGroupNo) throws Exception {
		log.debug("getLatestAlertsByUsername() 실행...! 회원: {}, 개수: {}", memUsername, cnt);
		
		Map<String, Object> params = new HashMap<>();
		params.put("memUsername", memUsername);
		params.put("cnt", cnt);
		params.put("artGroupNo", artGroupNo);
		
		return alertMapper.selectLatestAlertsByUsername(memUsername, cnt, artGroupNo);
	}


	@Override
	public int getUnreadAlertCnt(String memUsername) throws Exception {
		log.debug("getUnreadAlertCnt() 실행...! 회원: {}", memUsername);
		return alertMapper.cntUnreadAlerts(memUsername);
	}

	@Override
	@Transactional
	public boolean markAsRead(long alertNo, String memUsername) throws Exception {
		log.debug("markAsRead() 실행...! 알림번호: {}, 회원: {}", alertNo, memUsername);
		int updatedRows = alertMapper.markAsRead(alertNo, memUsername);
		return updatedRows > 0;
	}

	@Override
	@Transactional
	public void markAllAsRead(String memUsername) throws Exception {
		log.debug("markAllAsRead() 실행..! 회원: {}", memUsername);
		alertMapper.markAllAsRead(memUsername);
	}

	@Override
	@Transactional
	public boolean markAsDeleted(long alertNo, String memUsername) throws Exception {
		log.debug("markAsDeleted() 실행..! 알림번호: {}, 회원: {}", alertNo, memUsername);
		int updatedRows = alertMapper.markAsDeleted(alertNo, memUsername);
		return updatedRows > 0;
	}

	@Override
	public List<AlertSettingVO> getAlertSettings(String memUsername) throws Exception {	
		log.debug("getAlertSettings() 실행..! 회원: {}", memUsername);
		
		List<AlertSettingVO> savedSettings = alertMapper.selectAlertSettings(memUsername);		// 사용자에 저장된 설정 가져오기
		Map<String, AlertSettingVO> savedSettingsMap = savedSettings.stream()
				.collect(Collectors.toMap(AlertSettingVO::getAlertTypeCode, setting -> setting));
		
		String alertTypeGroupCode = "ALERT_TYPE_CODE";
		List<CommonCodeDetailVO> allAlertTypes = commonCodeMapper.selectCommonCodeDetails(alertTypeGroupCode);		// 모든 알림유형코드 조회
		
		List<AlertSettingVO> finalSettings = new ArrayList<>();		// 최종 알림설정 저장할 배열 생성
		Timestamp currentTime = new Timestamp(System.currentTimeMillis());		// 수정시간을 담을 변수 생성
		
		for(CommonCodeDetailVO alertType : allAlertTypes) {
			String typeCode = alertType.getCommCodeDetNo();
			
			AlertSettingVO finalSetting = savedSettingsMap.get(typeCode);
			
			if(finalSetting == null) {
				// 저장된 설정이 없으면 기본값 'Y'로 새로운 설정 생성
				finalSetting = new AlertSettingVO();			// 새로운 알림 설정 생성
				finalSetting.setMemUsername(memUsername);		// 설정할 회원아이디
				finalSetting.setAlertTypeCode(typeCode);		// 타입
				finalSetting.setAlertEnabledYn("Y");			// 사용 여부
				finalSetting.setAlertModDate(currentTime);		// 수정 시간
			}
			
			finalSetting.setAlertDescription(alertType.getDescription());
			finalSettings.add(finalSetting);
		}
		
		return finalSettings;
	}

	@Override
	@Transactional
	public void saveAlertSettings(List<AlertSettingVO> settings, String memUsername) throws Exception {
		log.debug("saveAlertSettings() 실행..! 알림 설정: {}, 회원: {}", settings, memUsername);
		// 개별 알림 설정
		if(settings == null || settings.isEmpty()) {
			log.warn("저장할 알림 설정이 없습니다.");
			return;
		}
		for(AlertSettingVO setting: settings) {
			
			setting.setMemUsername(memUsername);
			
			int updateRows = alertMapper.insertAlertSetting(setting);
			
			if(updateRows > 0) {
				log.info("알림 설정 저장/업데이트 성공!! , 타입 - {}, 회원 - {}", setting.getAlertTypeCode(), memUsername);
			} else {
				log.warn("알림 설정 저장/업데이트 실패..,  타입 - {}, 회원 - {}", setting.getAlertTypeCode(), memUsername);
			}
		}
		log.info("알림 설정 처리 완료. 총 {} 개 설정 처리 완료.", settings.size());
	}

	@Override
	@Transactional
	public List<AlertSettingVO> createDefalutAlertForUser(String username) throws Exception {
		log.debug("createDefalutAlertForUser() 실행...! 회원: {}", username);
		
		List<AlertSettingVO> settingsToSave = getAlertSettings(username);
		
		saveAlertSettings(settingsToSave, username);
		return settingsToSave;
	}

	
}
