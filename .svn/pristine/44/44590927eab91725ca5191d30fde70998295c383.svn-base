package kr.or.ddit.ddtown.controller.admin.goods;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import kr.or.ddit.ddtown.service.goods.cancel.ICancelService;
import kr.or.ddit.vo.PaginationInfoVO;
import kr.or.ddit.vo.order.OrderCancelVO;
import kr.or.ddit.vo.security.CustomOAuth2User;
import kr.or.ddit.vo.security.CustomUser;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Controller
@RequestMapping("/admin/goods/cancelRefund")
public class AdminGoodsCancelRefundController {
	
	@Autowired
	private ICancelService cancelService;

	/**
     * 관리자 주문 취소/환불 목록 페이지를 초기 로딩합니다.
     * JSP에서 <c:forEach>를 통해 초기 데이터를 렌더링할 수 있도록 List<OrderCancelVO>를 Model에 담습니다.
     * @param model View로 데이터를 전달하기 위한 Model 객체
     * @return JSP 뷰 경로
     */
    @GetMapping("/list") // "/admin/goods/cancelRefund/list" 에 매핑됩니다.
    public String goodsCancelRefundList(			@RequestParam(name = "currentPage", required = false, defaultValue = "1") int currentPage,
			@RequestParam(name = "searchKeyword", required = false, defaultValue = "") String searchKeyword,
			@RequestParam(name = "statusCode", required = false, defaultValue = "") String statusCode,
			Model model) {

		log.info("### AdminGoodsCancelRefundController - goodsCancelRefundList 호출");
		log.info("페이지네이션 요청: currentPage={}, searchKeyword={}, statusCode={}", currentPage, searchKeyword, statusCode);

		// 1. PaginationInfoVO 객체 초기화 및 현재 페이지 설정
		PaginationInfoVO<OrderCancelVO> pagingVO = new PaginationInfoVO<>();
		pagingVO.setCurrentPage(currentPage);
		// pageSize와 screenSize는 PaginationInfoVO 기본값(10, 5)을 사용하므로 따로 설정할 필요 없음.
		// 만약 변경하고 싶다면 pagingVO.setScreenSize(원하는값); 등으로 설정.

		// 2. 검색 조건을 담을 Map 생성 및 pagingVO에 설정
		Map<String, Object> searchMap = new HashMap<>();
		// searchKeyword와 statusCode를 searchMap에 담습니다.
		// 이 값들은 PaginationInfoVO의 searchMap 필드를 통해 Mapper로 전달됩니다.
		if (searchKeyword != null && !searchKeyword.isEmpty()) {
			searchMap.put("searchKeyword", searchKeyword);
		}
		if (statusCode != null && !statusCode.isEmpty()) {
			searchMap.put("statusCode", statusCode);
		}
		pagingVO.setSearchMap(searchMap); // PaginationInfoVO에 검색 조건 맵 설정

		// 3. 전체 레코드 수 조회 (필터링된 조건에 따라)
		int totalRecord = cancelService.getTotalCancelRefundCount(pagingVO);
		pagingVO.setTotalRecord(totalRecord); // 이 setter가 totalPage, startPage, endPage를 자동으로 계산합니다.

		// 4. 해당 페이지의 데이터 목록 조회
		List<OrderCancelVO> cancelList = cancelService.getFilteredCancelRefunds(pagingVO);
		pagingVO.setDataList(cancelList); // 조회된 데이터를 pagingVO에 설정

		// 5. Model에 PaginationInfoVO 객체 전달
		model.addAttribute("pagingVO", pagingVO);
		
		// 검색 필터 값을 JSP에 유지하기 위해 모델에 다시 추가 (선택 사항이지만 유용함)
		model.addAttribute("searchKeyword", searchKeyword);
		model.addAttribute("statusCode", statusCode);

		return "admin/goods/cancelRefund/cancel_refund_list";
    }
    
	
	 // 취소/환불 상세 페이지 (뷰를 반환)
    @GetMapping("/detail")
    public String cancelRefundDetailView(@RequestParam("cancelNo") int cancelNo, Model model) {
        // 이 메서드는 JSP 뷰를 반환하며, 초기 로드 시 데이터를 전달할 수도 있습니다.
        // 하지만 AJAX로 데이터를 가져올 것이므로, 여기서 직접 데이터를 Model에 담지는 않아도 됩니다.
        // 다만, URL 파라미터가 유효한지 검증하는 용도로 사용할 수 있습니다.
        log.info("취소/환불 상세 페이지 요청 - 취소번호: {}", cancelNo);
        // 필요하다면 여기서 한번 더 데이터 유효성을 검증하고, 없으면 에러 페이지로 리다이렉트
        return "admin/goods/cancelRefund/cancel_refund_detail"; // detail.jsp 경로
    }

    // ★★★ AJAX 요청으로 상세 데이터를 반환 (JSON 응답) ★★★
    @GetMapping("/detailData") // 별도의 JSON 데이터 제공 경로
    @ResponseBody // 이 어노테이션이 객체를 JSON으로 변환하여 HTTP 응답 본문에 넣어줍니다.
    public OrderCancelVO getCancelRefundDetailData(@RequestParam("cancelNo") int cancelNo) {
    	 log.info("### AJAX detailData 요청 시작 - 취소번호: {}", cancelNo); // 이 로그가 찍히나요?
        OrderCancelVO detail = cancelService.selectCancelDetail(cancelNo); // 서비스 계층 호출
        if (detail == null) {
            log.warn("취소번호 {} 에 해당하는 상세 데이터를 찾을 수 없습니다.", cancelNo);
            // HTTP 404 등으로 응답할 수도 있지만, null 반환 시 JSON은 null이 되거나 빈 객체가 될 수 있습니다.
            // 클라이언트에서 null 체크를 해야 합니다.
        }
        log.info("### AJAX detailData 서비스 응답: {}", detail); // 응답 객체 확인
        return detail;
    }
    
    /**
     * 취소/환불 상세 정보를 업데이트합니다. (상태, 상세 사유 등)
     * @param orderCancelVO 업데이트할 정보가 담긴 OrderCancelVO 객체 (JSON 형태로 전달)
     * @return 성공 여부를 담은 JSON 응답
     */
    @PostMapping("/update")
    @ResponseBody
    public Map<String, Object> updateCancelRefund(
            @RequestBody OrderCancelVO orderCancelVO,
            @AuthenticationPrincipal Object principal // 현재 로그인 사용자 정보를 주입받습니다.
            ) {
        log.info("취소/환불 정보 업데이트 요청: {}", orderCancelVO);

        Map<String, Object> response = new HashMap<>();
        String empUsername = null; // 로그인한 관리자 ID를 저장할 변수

        // 로그인한 사용자 정보에서 empUsername 추출 로직 (cancelOrder 메서드 참고)
        if (principal instanceof CustomUser) {
            CustomUser customUser = (CustomUser) principal;
            if (customUser.getEmployeeVO() != null) {
                empUsername = customUser.getEmployeeVO().getEmpUsername();
                log.info("로그인한 관리자 ID (Employee): {}", empUsername);
            } else {
                // 직원이 아닌 경우 (예: 일반 회원)
                log.warn("직원 계정이 아닌 Principal이 관리자 기능을 시도했습니다: {}", customUser.getUsername());
                response.put("success", false);
                response.put("message", "관리자 권한이 없습니다.");
                return response;
            }
        } else if (principal instanceof CustomOAuth2User) {
            // OAuth2 사용자는 보통 직원 계정이 아니므로, 여기서 차단
            log.warn("OAuth2 사용자가 관리자 기능을 시도했습니다: {}", ((CustomOAuth2User) principal).getName());
            response.put("success", false);
            response.put("message", "관리자 권한이 없습니다.");
            return response;
        } else {
            // 그 외 알 수 없는 Principal 타입이거나 로그인되지 않은 경우
            log.error("로그인 정보를 가져올 수 없거나 유효하지 않은 Principal 타입입니다.");
            response.put("success", false);
            response.put("message", "로그인 정보가 유효하지 않습니다. 다시 로그인 해주세요.");
            return response;
        }

        // empUsername이 null이면 위에서 이미 return 되었을 것이지만, 방어 코드 추가
        if (empUsername == null || empUsername.isEmpty()) {
            log.error("관리자 ID를 가져오는 데 실패했습니다.");
            response.put("success", false);
            response.put("message", "로그인 정보를 확인해주세요.");
            return response;
        }
        
        // OrderCancelVO에 empUsername 설정 (DB에 저장하기 위함)
        orderCancelVO.setEmpUsername(empUsername);

        try {
            // 비즈니스 로직: 상태가 'DONE' (환불완료)으로 변경될 때 처리일 자동 설정
            if ("DONE".equals(orderCancelVO.getCancelStatCode())) {
                orderCancelVO.setCancelResDate(new Date());
                log.info("환불완료 상태로 변경되어 처리일이 {}로 설정됩니다.", orderCancelVO.getCancelResDate());
            } else if ("REJ".equals(orderCancelVO.getCancelStatCode()) &&
                       (orderCancelVO.getCancelReasonDetail() == null || orderCancelVO.getCancelReasonDetail().trim().isEmpty())) {
                // "요청거부" 시 상세 사유가 비어있으면 오류
                response.put("success", false);
                response.put("message", "요청 거부 시 상세 사유는 필수입니다.");
                return response;
            }

            int result = cancelService.updateCancelRefund(orderCancelVO); // 서비스 호출

            if (result > 0) {
                response.put("success", true);
                response.put("message", "성공적으로 업데이트되었습니다.");
            } else {
                response.put("success", false);
                response.put("message", "업데이트에 실패했습니다. 데이터를 찾을 수 없거나 변경 사항이 없습니다.");
            }
        } catch (Exception e) {
            log.error("취소/환불 정보 업데이트 중 오류 발생: {}", e.getMessage(), e);
            response.put("success", false);
            response.put("message", "서버 오류가 발생했습니다.");
            response.put("error", e.getMessage());
        }
        return response;
    }
}
